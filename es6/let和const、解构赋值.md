# let和const

本文记录let和const的一些新特性

### 1.块级作用域

let和const定义的变量产生块级作用域，在块级作用域外访问都会报错。

块级作用域的出现，使得立即执行函数不再必要了。

### 2.不存在变量提升

let和const申明的变量不存在变量提升，因此不能先使用再定义。

### 3.不允许重复申明

不允许在相同的作用域里重复申明。

### 4.暂时性死区

在代码块内，使用let命令声明变量之前，该变量都是不可用的。这种现象称之为“暂时性死区（TDZ）”。

### 5.const的特殊之处

const声明一个只读的常量。一旦声明，常量的值就不能改变。

***但是复杂值比如对象，因为是引用类型，因此可以对其属性赋值或者变更。但是不能对const的变量重新定义，改变引用的地址。**



# 解构赋值

解构赋值比较常用，主要记录下解构赋值的用途：

### 1.交换变量的值

```js
let x = 1;
let y = 2;

[x, y] = [y, x];
```

也可以用于复杂数据类型的变量交换。

### 2.从函数返回多个值

```js
function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
```

返回一个对象，通过解构拿到多个值；

### 3.函数参数定义

```js
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
```

这样比传统按顺序传参有个好处就是可以不用保证参数的顺序！

### 4.**输入模块的指定方法**

```js
const { SourceMapConsumer, SourceNode } = require("source-map");
```

非常常用的功能不多介绍。

